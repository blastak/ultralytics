class QBB(BaseTensor):
    """
    A class for storing and manipulating Quadrilateral Bounding Boxes (QBB).

    This class provides functionality to handle quadrilateral bounding boxes, including conversion between
    different formats, normalization, and access to various properties of the boxes. It supports
    both tracking and non-tracking scenarios.

    Attributes:
        data (torch.Tensor): The raw QBB tensor containing box coordinates and associated data.
        orig_shape (tuple): Original image size as (height, width).
        is_track (bool): Indicates whether tracking IDs are included in the box data.
        xywhr (torch.Tensor | np.ndarray): Boxes in [x_center, y_center, width, height, rotation] format.
        conf (torch.Tensor | np.ndarray): Confidence scores for each box.
        cls (torch.Tensor | np.ndarray): Class labels for each box.
        id (torch.Tensor | np.ndarray): Tracking IDs for each box, if available.
        xyxyxyxy (torch.Tensor | np.ndarray): Boxes in 8-point [x1, y1, x2, y2, x3, y3, x4, y4] format.
        xyxyxyxyn (torch.Tensor | np.ndarray): Normalized 8-point coordinates relative to orig_shape.
        xyxy (torch.Tensor | np.ndarray): Axis-aligned bounding boxes in [x1, y1, x2, y2] format.

    Methods:
        cpu: Return a copy of the QBB object with all tensors on CPU memory.
        numpy: Return a copy of the QBB object with all tensors as numpy arrays.
        cuda: Return a copy of the QBB object with all tensors on GPU memory.
        to: Return a copy of the QBB object with tensors on specified device and dtype.

    Examples:
        >>> boxes = torch.tensor([[100, 50, 150, 100, 30, 0.9, 0]])  # xywhr, conf, cls
        >>> qbb = QBB(boxes, orig_shape=(480, 640))
        >>> print(qbb.xyxyxyxy)
        >>> print(qbb.conf)
        >>> print(qbb.cls)
    """

    def __init__(self, boxes: Union[torch.Tensor, np.ndarray], orig_shape: Tuple[int, int]) -> None:
        """
        Initialize an QBB (Quadrilateral Bounding Box) instance with quadrilateral bounding box data and original image shape.

        This class stores and manipulates Quadrilateral Bounding Boxes (QBB) for object detection tasks. It provides
        various properties and methods to access and transform the QBB data.

        Args:
            boxes (torch.Tensor | np.ndarray): A tensor or numpy array containing the detection boxes,
                with shape (num_boxes, 7) or (num_boxes, 8). The last two columns contain confidence and class values.
                If present, the third last column contains track IDs, and the fifth column contains rotation.
            orig_shape (Tuple[int, int]): Original image size, in the format (height, width).

        Attributes:
            data (torch.Tensor | np.ndarray): The raw QBB tensor.
            orig_shape (Tuple[int, int]): The original image shape.
            is_track (bool): Whether the boxes include tracking IDs.

        Raises:
            AssertionError: If the number of values per box is not 7 or 8.

        Examples:
            >>> import torch
            >>> boxes = torch.rand(3, 7)  # 3 boxes with 7 values each
            >>> orig_shape = (640, 480)
            >>> qbb = QBB(boxes, orig_shape)
            >>> print(qbb.xywhr)  # Access the boxes in xywhr format
        """
        if boxes.ndim == 1:
            boxes = boxes[None, :]
        n = boxes.shape[-1]
        assert n in {7, 8}, f"expected 7 or 8 values but got {n}"  # xywh, rotation, track_id, conf, cls
        super().__init__(boxes, orig_shape)
        self.is_track = n == 8
        self.orig_shape = orig_shape

    @property
    def xywhr(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Return boxes in [x_center, y_center, width, height, rotation] format.

        Returns:
            (torch.Tensor | np.ndarray): A tensor or numpy array containing the quadrilateral bounding boxes with format
                [x_center, y_center, width, height, rotation]. The shape is (N, 5) where N is the number of boxes.

        Examples:
            >>> results = model("image.jpg")
            >>> qbb = results[0].qbb
            >>> xywhr = qbb.xywhr
            >>> print(xywhr.shape)
            torch.Size([3, 5])
        """
        return self.data[:, :5]

    @property
    def conf(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Return the confidence scores for Quadrilateral Bounding Boxes (QBBs).

        This property retrieves the confidence values associated with each QBB detection. The confidence score
        represents the model's certainty in the detection.

        Returns:
            (torch.Tensor | np.ndarray): A tensor or numpy array of shape (N,) containing confidence scores
                for N detections, where each score is in the range [0, 1].

        Examples:
            >>> results = model("image.jpg")
            >>> qbb_result = results[0].qbb
            >>> confidence_scores = qbb_result.conf
            >>> print(confidence_scores)
        """
        return self.data[:, -2]

    @property
    def cls(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Return the class values of the quadrilateral bounding boxes.

        Returns:
            (torch.Tensor | np.ndarray): A tensor or numpy array containing the class values for each quadrilateral
                bounding box. The shape is (N,), where N is the number of boxes.

        Examples:
            >>> results = model("image.jpg")
            >>> result = results[0]
            >>> qbb = result.qbb
            >>> class_values = qbb.cls
            >>> print(class_values)
        """
        return self.data[:, -1]

    @property
    def id(self) -> Optional[Union[torch.Tensor, np.ndarray]]:
        """
        Return the tracking IDs of the quadrilateral bounding boxes (if available).

        Returns:
            (torch.Tensor | np.ndarray | None): A tensor or numpy array containing the tracking IDs for each
                quadrilateral bounding box. Returns None if tracking IDs are not available.

        Examples:
            >>> results = model("image.jpg", tracker=True)  # Run inference with tracking
            >>> for result in results:
            ...     if result.qbb is not None:
            ...         track_ids = result.qbb.id
            ...         if track_ids is not None:
            ...             print(f"Tracking IDs: {track_ids}")
        """
        return self.data[:, -3] if self.is_track else None

    @property
    @lru_cache(maxsize=2)
    def xyxyxyxy(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Convert QBB format to 8-point (xyxyxyxy) coordinate format for quadrilateral bounding boxes.

        Returns:
            (torch.Tensor | np.ndarray): Rotated bounding boxes in xyxyxyxy format with shape (N, 4, 2), where N is
                the number of boxes. Each box is represented by 4 points (x, y), starting from the top-left corner and
                moving clockwise.

        Examples:
            >>> qbb = QBB(torch.tensor([[100, 100, 50, 30, 0.5, 0.9, 0]]), orig_shape=(640, 640))
            >>> xyxyxyxy = qbb.xyxyxyxy
            >>> print(xyxyxyxy.shape)
            torch.Size([1, 4, 2])
        """
        return ops.xywhr2xyxyxyxy(self.xywhr)

    @property
    @lru_cache(maxsize=2)
    def xyxyxyxyn(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Convert quadrilateral bounding boxes to normalized xyxyxyxy format.

        Returns:
            (torch.Tensor | np.ndarray): Normalized quadrilateral bounding boxes in xyxyxyxy format with shape (N, 4, 2),
                where N is the number of boxes. Each box is represented by 4 points (x, y), normalized relative to
                the original image dimensions.

        Examples:
            >>> qbb = QBB(torch.rand(10, 7), orig_shape=(640, 480))  # 10 random QBBs
            >>> normalized_boxes = qbb.xyxyxyxyn
            >>> print(normalized_boxes.shape)
            torch.Size([10, 4, 2])
        """
        xyxyxyxyn = self.xyxyxyxy.clone() if isinstance(self.xyxyxyxy, torch.Tensor) else np.copy(self.xyxyxyxy)
        xyxyxyxyn[..., 0] /= self.orig_shape[1]
        xyxyxyxyn[..., 1] /= self.orig_shape[0]
        return xyxyxyxyn

    @property
    @lru_cache(maxsize=2)
    def xyxy(self) -> Union[torch.Tensor, np.ndarray]:
        """
        Convert quadrilateral bounding boxes (QBB) to axis-aligned bounding boxes in xyxy format.

        This property calculates the minimal enclosing rectangle for each quadrilateral bounding box and returns it in
        xyxy format (x1, y1, x2, y2). This is useful for operations that require axis-aligned bounding boxes, such
        as IoU calculation with non-quadrilateral boxes.

        Returns:
            (torch.Tensor | np.ndarray): Axis-aligned bounding boxes in xyxy format with shape (N, 4), where N
                is the number of boxes. Each row contains [x1, y1, x2, y2] coordinates.

        Examples:
            >>> import torch
            >>> from ultralytics import YOLO
            >>> model = YOLO("yolo11n-qbb.pt")
            >>> results = model("path/to/image.jpg")
            >>> for result in results:
            ...     qbb = result.qbb
            ...     if qbb is not None:
            ...         xyxy_boxes = qbb.xyxy
            ...         print(xyxy_boxes.shape)  # (N, 4)

        Notes:
            - This method approximates the QBB by its minimal enclosing rectangle.
            - The returned format is compatible with standard object detection metrics and visualization tools.
            - The property uses caching to improve performance for repeated access.
        """
        x = self.xyxyxyxy[..., 0]
        y = self.xyxyxyxy[..., 1]
        return (
            torch.stack([x.amin(1), y.amin(1), x.amax(1), y.amax(1)], -1)
            if isinstance(x, torch.Tensor)
            else np.stack([x.min(1), y.min(1), x.max(1), y.max(1)], -1)
        )


